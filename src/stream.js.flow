// @flow

import type { EventEmitter } from 'events'
import type { Readable } from 'stream'

import type { Filter, ForEach, Map, Reduce } from './fp/stream'

declare class Stream<T> {
  constructor(source: AsyncIterable<T>): void;

  @@asyncIterator(): AsyncIterator<T>;
  chain<U>(source: AsyncIterable<U>): Stream<T | U>;
  count(): Promise<number>;
  enumerate(): Stream<[number, T]>;
  every(fn: Filter<T>): Promise<boolean>;
  filter(fn: Filter<T>): Stream<T>;
  filterMap<U>(fn: Map<T, ?U>): Stream<U>;
  find(fn: Filter<T>): Promise<T | void>;
  first(): Promise<T | void>;
  flatMap<U>(fn: Map<T, AsyncIterable<U>>): Stream<U>;
  forEach(fn: ForEach<T>): Promise<void>;
  join(sep?: string): Promise<string>;
  last(): Promise<T | void>;
  map<U>(fn: Map<T, U>): Stream<U>;
  next(): Promise<IteratorResult<T, void>>;
  nth(index: number): Promise<T | void>;
  product(): Promise<number>;
  reduce(fn: Reduce<T, T>, init?: void): Promise<T>;
  reduce<U>(fn: Reduce<T, U>, init: U): Promise<U>;
  skip(amount: number): Stream<T>;
  skipWhile(fn: Filter<T>): Stream<T>;
  some(fn: Filter<T>): Promise<boolean>;
  sum(): Promise<number>;
  take(amount: number): Stream<T>;
  takeWhile(fn: Filter<T>): Stream<T>;
  tap(fn: ForEach<T>): Stream<T>;
  zip<U>(source: AsyncIterable<U>): Stream<[T, U]>;
}

declare export function from<T>(source: AsyncIterable<T>): Stream<T>;
declare export function fromEvent(source: EventEmitter, event: string): Stream<*>;
declare export function fromReadable(source: Readable): Stream<Buffer | string>;
declare export function range(start?: number, end?: number): Stream<number>;
declare export function repeat<T>(value: T): Stream<T>;
